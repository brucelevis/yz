###跨服流程###
	跨服流程:主要包括去跨服(去其他服),回原服
	假定存在玩家C，他在HS服，有其他GS1，GS2服
	C从HS服到GS1服:
		1. HS生成认证token，发到GS1
		2. HS打包"连接指定服务器"({token=token,go_srvname=GS1,home_srvname=HS})给C
		3. HS将C踢下线
		4. C收到"连接指定服务器"时，开始连接GS1,并透传收到的信息(包括认证token)
		5. GS1根据token认证，认证通过后允许C进入游戏
		6. GS1通知HS，C跨服成功，HS将C标记成正在跨服GS1
		7. C走进入游戏流程

	C从GS1服回到原服HS
		1. GS1生成认证token，发到HS
		2. GS1打包"连接指定服务器"({token=token,go_srvname=HS})给C
		3. GS1将C踢下线,并通知HS删除C的跨服标记
		4. C收到"连接指定服务器"时，开始连接HS,并透传收到的信息(包括认证token)
		5. HS根据token认证,认证通过后允许C进入游戏
		6. C走进入游戏流程

	C从GS1到GS2
		1. GS1生成认证token，发到GS2
		2. GS1打包"连接指定服务器"({token=token,go_srvname=GS2,home_srvname=HS})给C
		3. GS1将C踢下线
		4. C收到"连接指定服务器"时，开始连接GS2,并透传收到的信息(包括认证token)
		5. GS2根据token认证，认证通过由允许C进入游戏
		6. GS2通知HS，C跨服成功,HS将C的跨服标记置成GS2
		7. C走进入游戏流程

	C从GS2下线流程
		1. GS2将C下线
		2. HS心跳检查C在GS2是否在线，如果不在线，则删除C的跨服标记


	跨服放到玩家身上数据有
	home_srvname #原服名
	player_data    #原服传来的信息[如原服服务器等级等]

	跨服标记中记录的数据有
	go_srvname	#去往的跨服


###服务器架构###
	1. 游戏逻辑服： 负责游戏常规逻辑，主要玩法
	2. 战斗服:		每个游戏逻辑服对应一个自己的战斗服，战斗服主要用来处理战斗逻辑
	3. 数据中心:	为了便于集中管理一些常用属性，如每个玩家的简介信息，玩家的简介信息
					经常被跨服玩法使用，如跨服好友
	4. 功能服:		排行榜服，工会服，跨服战服，部分重要活动专有服等等
	5. 帐号中心:	管理玩家帐号，登录认证,充值

###基础支持###
	1. 要做世界服，首先需要处理的是玩家->原服，玩家->当前所在服的路由,只有我们知道指定玩家
		在指定服时才能对其做后续操作。我们可以将玩家的原服,当前所在服存到数据中心的玩家
		简介信息中。
	
	2. 推送机制，对于玩家简介信息，系统已经支持更新+即时同步。任何服引用的玩家简介信息，当
		该简介变化时都能即使同步更新

###注意事项###
	1. 数据的一致性
		世界服重点是保证数据一致。要保证数据一致，需要保证跨服对象同一时刻只存在一个“可写对像”。
		实际上我们是无法保证同一个玩家只存在一份实例，例如：策划可能有离线载入某个玩家做某事
		的需求，如果这个玩家正在跨服，原服就会载入一份他的离线拷贝，只要我们标记这份离线数据
		为“只读”对象，就不会引起同一个玩家有多个实例可写的数据覆盖问题。对于策划也应该理解
		这一点，避免设计一些离线修改玩家数据的玩法
	2. 操作的时序问题
		假定工会设计成所有服的人都能加入同一个工会，对于工会共享资源，如果存在不同服的成员同时
		操作,此时扣除资源的操作就必须保证时序。这种情况我们是不能用本服缓存的工会资源做判定，必
		需将扣除资源操作通知工会所在的功能服，让资源真正所在的服务来进行扣除，同一个服才能保证时序
		

###友好接口###
	1. rpc调用引擎已经提供良好支持，上层只做了简单包装。为了方便操作，对于跨服玩家专门提供了一个代理
	玩家对象，用法如下:
	local pid = 1000001
	if not playermgr.getkuafuplayer(pid) then
		return
	end
	local player = cproxyplayer.new(pid)
	player.itemdb:additembytype(105001,10,nil,"test:rpc")
	local addgold = player:addgold(10,"test:rpc")
	print(addgold)  -- 10
	--只支持rpc调用函数，并且需要保证调用的函数,参数和返回值是"值类型",暂时不支持rpc获取属性

###角色ID到DB的路由###
	考虑过的方案:
	1. 各服存本服角色列表,启服时广播给其他服,新增/删除角色时增量同步
		缺点: 过于依赖路由表,并且服务器宕机情况下可能丢失部分路由信息，
		经讨论，已排除该方案
	2. 对同一个区,用指定个数db保存角色信息,根据算法:角色ID%db个数来确定角色存放的db
		优点:可以保证角色信息的存储和逻辑服完全分离
		缺点:由于逻辑服仍然会做部分功能（如简单的本服活动)，即逻辑服仍然有属于自身服的
			 私有数据，如果角色信息单独用db存储，那每个逻辑服还必须配一个从属于本服的私
			 有db，这样会将逻辑复杂化
	3. 保证roleid的生成和服务器编号srvno相关,通过roleid可以反向推出srvno，每个srvno对应
	   一个db,roleid=srvno*1000000+roleid递增序号
	   优点: 1. 服务器私有数据和这个服创建的角色数据可以存到同一个db下,可以简化逻辑
	         2. 对合服无限制，允许策划指定任意两个逻辑服合服
	   缺点: 1. 转服玩家roleid->srvno的映射需要专门用特定路由表记录

	当前我们采用第3种方案，仍然可以保证宿主服挂掉后经过roleid->db的路由，从
	其他服载入玩家数据,即玩家可以脱离宿主服运行

###优化###
	1. 上次讨论中建议用中心节点保存玩家数据的载入/存盘状态，来保证跨服时玩家数据写入完毕后再被载出。
	这个问题的关键是保证写入,载出操作的先后时序。我们没有采用中心节点来实现这种方案，而是优化跨
	服流程,保证玩家数据写入完毕后再通知客户端跨服
	2. 登录省去选服界面。该功能正在开发中，只需上层逻辑支持，不影响整体结构和登录流程
	3. 聊天服务器，我觉得没必要，策划现在设计上不会允许不同服的世界聊天，只是喇叭这种同区广播，这
	种开销不至于专门开聊天服务器。现在很多功能玩法也会有同区广播的，如:同区发布队伍。这种开销效率
	上不会有太大的负担。


