cpetdb = class("cpetdb",cposcontainer)

function cpetdb:init(pid)
	cposcontainer.init(self,{
		pid = pid,
		name = "cpetdb",
		initspace = 4,
	})
	self.pid = pid
	self.expandspace = 0
	self.readywar_petid = nil
end

function cpetdb:load(data)
	if not data or not next(data) then
		return
	end
	cposcontainer.load(self,data,function(petdata)
		local pet = petaux.newpet()
		pet:load(petdata)
		pet:config()
		return pet
	end)
	self.expandspace = data.expandspace
	self.readywar_petid = data.readywar_petid
	local pet = self:getpet(self.readywar_petid)
	if pet then
		pet.readywar = true
	else
		self.readywar_petid = nil
	end
	return data
end

function cpetdb:save()
	local data = cposcontainer.save(self,function(pet)
		return pet:save()
	end)
	data.expandspace = self.expandspace
	data.readywar_petid = self.readywar_petid
	return data
end

function cpetdb:onlogin(player)
	assert(player.pid == self.pid)
	local pets = {}
	for id,pet in pairs(self.objs) do
		table.insert(pets,pet:pack())
	end
	sendpackage(self.pid,"pet","allpet",{
		pets = pets,
		space = self:getspace(),
	})
end

function cpetdb:getpet(petid)
	return self:get(petid)
end

function cpetdb:addpet(pet,reason)
	local pos = self:getfreepos()
	assert(pos)
	local petid = self:genid()
	logger.log("info","pet",string.format("[addpet] pid=%s petid=%s pettype=%s pos=%s reason=%s",self.pid,petid,pet.type,pos,reason))
	pet.pos = pos
	self:add(pet,petid)
	return pet
end

function cpetdb:delpet(petid,reason)
	local pet = self:getpet(petid)
	if pet then
		logger.log("info","pet",string.format("[delpet] pid=%s petid=%s pettype=%s pos=%s reason=%s",self.pid,petid,pet.type,pet.pos,reason))
		local pos = pet.pos
		local space = self:getspace()
		self:del(petid)
		for i=pos+1,space do
			self:moveto(i,i-1)
		end
		return pet
	end
end

function cpetdb:readywar(petid)
	local pet = self:getpet(petid)
	if not pet then
		return
	end
	self.readywar_petid = petid
	self:update(pet.id,{
		readywar = true,
	})
	return pet
end

function cpetdb:unreadywar(petid)
	local pet = self:getpet(petid)
	if not pet then
		return
	end
	self.readywar_petid = nil
	self:update(pet.id,{
		readywar = false,
	})
	return pet
end

function cpetdb:addclose(petid,addclose,reason)
	local pet = self:getpet(petid)
	if not pet then
		return 0
	end
	logger.log("info","pet",string.format("[addclose] pid=%d petid=%s close=%d reason=%s",self.pid,petid,addclose,reason))
	local newval = pet.close + addclose
	local addlv = 0
	local maxlv = #data_1700_PetRelationShip
	for lv=pet.relationship+1,maxlv do
		local data = data_1700_PetRelationShip[lv]
		if newval >= data.needclose then
			newval = newval - data.needclose
			addlv = addlv + 1
		else
			break
		end
	end
	self:update(petid,{
		relationship = pet.relationship + addlv,
		close = newval,
	})
	return addclose
end

function cpetdb:change_petstatus(petid,status,reason)
	local pet = self:getpet(petid)
	if not pet then
		return
	end
	logger.log("info","pet",string.format("[changestatus] pid=%d petid=%s status=%s reason=%s",self.pid,petid,status,reason))
	self:update(petid,{
		status = status,
	})
	return status
end

function cpetdb:trainpet(petid)
	local pet = self:getpet(petid)
	if not pet then
		return
	end
	local data = petaux.getpetdata(pet.type)
	-- 处理技能
	local oldskills = pet:getallskills()
	pet.skills:clear()
	for _,skillid in pairs(data.study_skills) do
		if ishit(50,100) then
			pet:addskill(skillid)
		end
	end
	-- 处理资质
	local fullzizhi = pet:query("fullzizhi",{})
	local basic_downratio = 5
	local oldzizhi = pet.zizhi
	pet.zizhi = {}
	for name,value in pairs(oldzizhi) do
		-- 洗出满资质后，下一次训练不变
		if not fullzizhi[name] then
			local max = data[name] * pet.zizhi_maxratio / 100
			local addition_downratio = math.floor(10 * value / max)
			local newvalue
			if ishit(basic_downratio + addition_downratio,100) then
				local add = math.random(1,9)
				newvalue = pet:setzizhi(name,value + add)
			else
				local reduce = math.random(1,9)
				newvalue = pet:setzizhi(name,value - reduce)
			end
			if newvalue < max then
				fullzizhi[name] = nil
			else
				fullzizhi[name] = true
			end
		end
	end
	pet:set("fullzizhi",fullzizhi)
	local newskills = pet:getallskills()
	logger.log("info","pet",format("[trainpet] pid=%d petid=%d oldzz=%s newzz=%s oldsk=%s newsk=%s",self.pid,petid,oldzizhi,pet.zizhi,oldskills,newskills))
	self:onupdate(petid,{
		skills = newskills,
		zizhi = pet.zizhi,
	})
end

function cpetdb:comprehendskill(petid)
	local pet = self:getpet(petid)
	if not pet then
		return
	end
	local limit = pet.skills:getspace()
	if pet:getskillslen() >= limit then
		return
	end
	local ratio = (limit - pet:getskillslen() - 3) * 5 + pet.lv
	if ratio <= 0 or not ishit(ratio,1000000) then
		return
	end
	local tmp = {}
	for skillid,skilldata in pairs(data_1700_PetSkill) do
		if skilldata.comprehend_ratio ~= 0 and self:can_learn(pet,skillid) then
			tmp[skillid] = skilldata.comprehend_ratio
		end
	end
	local skillid = choosekey(tmp)
	local player = playermgr.getplayer(self.pid)
	logger.log("info","pet",string.format("[comprehendskill] pid=%d petid=%d skillid=%d",self.pid,petid,skillid))
	pet:addskill(skillid)
	net.msg.sendquickmsg(language.format("恭喜{1}的{2}领悟了{3}！",player.name,pet:get("name"),data_1700_PetSkill[skillid].name))
	self:onupdate(petid,{
		skills = pet:getallskills(),
	})
end

function cpetdb:learnskill(petid,skillid)
	local pet = self:getpet(petid)
	if not pet then
		return
	end
	local replaceskill,replace_skillpos
	local skillslen = pet:getskillslen()
	if skillslen > 5 then
		local ratio = math.max(0,math.floor((pet.skills.len - 2) / 3))
		if skillslen >= pet.skills:getspace() or ishit(ratio,100) then
			replaceskill = randlist(table.keys(pet.skills.objs))
			replace_skillpos = pet:hasskill(replaceskill)
			pet:delskill(replaceskill)
		end
	end
	pet:addskill(skillid,replace_skillpos)
	local msg
	if not replace_skillpos then
		msg = language.format("{1}学习成功",data_1700_PetSkill[skillid].name)
	else
		msg = language.format("{1}替换了{2}",data_1700_PetSkill[skillid].name,data_1700_PetSkill[replaceskill].name)
	end
	net.msg.S2C.notify(self.pid,msg)
	logger.log("info","pet",string.format("[learnskill] pid=%d petid=%d skillid=%d replacesk=%d",self.pid,pet.id,skillid,replaceskill or 0))
	self:onupdate(petid,{
		skills = pet:getallskills(),
	})
end

function cpetdb:can_learn(pet,skillid)
	if pet:hasskill(skillid) then
		return false,language.format("已经学习过该技能了")
	end
	local skilldata = data_1700_PetSkill[skillid]
	if istrue(skilldata.relation_limit) and pet.relationship < skilldata.relation_limit then
		return false,language.format("宠物关系达不到{1}，无法学习本技能",data_1700_PetRelationShip[skilldata.relation_limit].name)
	end
	if istrue(skilldata.lv_limit) and pet.lv < skilldata.lv_limit then
		return false,language.format("宠物等级达不到{1}，无法学习本技能",skilldata.lv_limit)
	end
	if istrue(skilldata.lv_limit) and pet:get("quality") < skilldata.quality_limit then
		return false,language.format("宠物品质达不到{1}，无法学习本技能",PET_QUALITY[skilldata.quality_limit])
	end
	if istrue(skilldata.race_limit) and pet:get("race") ~= skilldata.race_limit then
		return false,language.format("宠物不是{1}种族，无法学习本技能",PET_RACE[skilldata.race_limit])
	end
	if istrue(skilldata.category_limit) and pet:get("category") ~= skilldata.category_limit then
		return false,language.format("宠物不是{1}类别，无法学习本技能",PET_CATEGORY[skilldata.category_limit])
	end
	if istrue(skilldata.type_limit) and pet:get("type") ~= skilldata.type_limit then
		return false,language.format("宠物不是{1}类型，无法学习本技能",PET_TYPE[skilldata.type_limit])
	end
	for name,value in pairs(pet.zizhi) do
		if istrue(value) and skilldata[name] > value then
			return false,language.format("{1}的{2}资质达不到{3}，无法学习本技能",pet:get("name"),PET_ZIZHI[name],skilldata[name])
		end
	end
	return true
end

function cpetdb:wieldequip(petid,itemid)
	local pet = self:getpet(petid)
	if not pet then
		return false
	end
	local isok,msg = self:can_wieldequip(pet,itemid)
	if not isok then
		return isok,msg
	end
	local player = playermgr.getplayer(self.pid)
	local equip = player.itemdb:delitem(itemid,"wield_petequip")
	local equippos = itemaux.getitemdata(equip.type).equippos
	local item = pet.equipments:delbypos(equippos)
	if item then
		player.itemdb:additem(item,"unwield_petequip")
	end
	logger.log("info","pet",string.format("[wieldequip] pid=%d petid=%d itemid=%d",self.pid,petid,itemid))
	equip.pos = equippos
	pet.equipments:add(equip,equip.id)
	self:onupdate(petid,{
		equips =  pet:getallequips(),
	})
end

function cpetdb:can_wieldequip(pet,itemid)
	local player = playermgr.getplayer(self.pid)
	local item = player:getitem(itemid)
	if not item then
		return false,language.format("背包中没有找到该装备")
	end
	if itemaux.getmaintype(item.type) ~= ItemMainType.PETEQUIP then
		return false,language.format("该物品无法给宠物装备")
	end
	if itemaux.getitemdata(item.type).equippos > pet.equipments:getspace() then
		return false
	end
	return true
end

function cpetdb:unwieldequip(petid,itemid)
	local pet = self:getpet(petid)
	if not pet then
		return false
	end
	local player = playermgr.getplayer(self.pid)
	if not pet.equipments:get(itemid) then
		return
	end
	logger.log("info","pet",string.format("[unwieldequip] pid=%d petid=%d itemid=%d",self.pid,petid,itemid))
	local item = pet.equipments:del(itemid)
	if player.itemdb:getfreespace() > 0 then
		player.itemdb:additem(item,"unwield_petequip")
	else
		mailmgr.sendmail(self.pid,{
			srcid = SYSTEM_MAIL,
			author = "系统",
			title = "宠物装备",
			content = string.format("由于背包已满，宠物%s身上的装备以邮件形式退发给您",pet:getname()),
			attach = {
				items = {item:save(),},
			},
		})
	end
	self:onupdate(petid,{
		equips = pet:getallequips(),
	})
end

function cpetdb:combine(masterid,subid)
	local isok,msg = self:can_combine(masterid,subid)
	if not isok then
		if msg then
			net.msg.S2C.notify(self.pid,msg)
		end
		return
	end
	local masterpet,subpet = self:getpet(masterid),self:getpet(subid)
	logger.log("info","pet",string.format("[combinepet] pid=%d masterid=%d subid=%d",self.pid,masterid,subid))
	for itemid,_ in pairs(subpet.equipments.objs) do
		self:unwieldequip(subid,itemid)
	end
	self:delpet(subid,"combine")
	--资质调整
	for name,_ in pairs(masterpet.zizhi) do
		local zizhi = math.floor((masterpet.zizhi[name] / masterpet:getzizhilimit(name) + subpet.zizhi[name] / subpet:getzizhilimit(name)) / 2 * masterpet:getzizhilimit(name))
		masterpet:setzizhi(name,zizhi)
	end
	--技能调整
	local lstskill = {}
	for _,skill in pairs(masterpet.skills.objs) do
		table.insert(lstskill,skill.id)
	end
	local lstskill2 = {}
	for _,skill in pairs(subpet.skills.objs) do
		if not masterpet:hasskill(skill.id) then
			table.insert(lstskill2,skill.id)
		end
	end
	local rand = math.random(data_1700_PetVar.CombineSkillMinRatio * 100,data_1700_PetVar.CombineSkillMaxRatio * 100) / 100
	local skillnum = #lstskill + math.floor(#lstskill2 * rand)
	skillnum = math.min(skillnum,masterpet.skills:getspace() - #masterpet:get("bind_skills"))
	table.extend(lstskill,lstskill2)
	lstskill = shuffle(lstskill,false,skillnum)
	masterpet.skills:clear()
	for _,skillid in ipairs(lstskill) do
		masterpet:addskill(skillid)
	end
	self:onupdate(masterid,{
		zizhi = masterpet.zizhi,
		skills = masterpet:getallskills(),
	})
	--变异
	if not masterpet:isbianyi() then
		local ratio = masterpet:get("bianyi_ratio") - (petaux.bianyifix(masterpet) - petaux.bianyifix(subpet)) ^ 2
		if ishit(ratio,100) then
			self:bianyi(masterid,"combine")
			local player = playermgr.getplayer(self.pid)
			local skillid = masterpet:getbianyiskill()
			local skillname = data_1700_PetSkill[skillid].name
			net.msg.sendquickmsg(language.format("{1}的{2}在合成时产生了变异，获得了变异技能{3}",player.name,masterpet:name(),skillname))
		end
	end
	net.msg.S2C.notify(self.pid,language.format("合成宠物成功"))
end

function cpetdb:can_combine(masterid,subid)
	local player = playermgr.getplayer(self.pid)
	if player.lv < 30 then
		return false,language.format("玩家到达30级才能合成宠物")
	end
	local masterpet,subpet = self:getpet(masterid),self:getpet(subid)
	if not masterpet or not subpet then
		return false
	end
	if masterpet.lv < 30 or subpet.lv < 30 then
		return false,language.format("宠物到达30级才能作为合成材料")
	end
	if subpet:isbianyi() then
		return false,language.format("变异宠物不能作为副宠")
	end
	if masterpet.readywar or subpet.readywar then
		return false,language.format("出战宠不能进行合成")
	end
	return true
end

function cpetdb:rename(petid,name)
	local pet = self:getpet(petid)
	if not pet then
		return
	end
	local isok,msg = self:validtext(name)
	if not isok then
		if msg then
			net.msg.S2C.notify(self.pid,msg)
		end
		return
	end
	self:update(petid,{
		name = name,
	})
end

function cpetdb:setchat(petid,case,chat)
	local pet = self:getpet(petid)
	if not pet or case <= 0  or case > #pet.chats then
		return
	end
	local isok,msg = self:validtext(chat)
	if not isok then
		if msg then
			net.msg.S2C.notify(self.pid,msg)
		end
		return
	end
	local chats = pet.chats
	chats[case] = chat
	self:update(petid,{
		chats = chats,
	})
end

function cpetdb:validtext(str)
	local isok,filter_name = wordfilter.filter(str)
	if not isok then
		return false,language.format("文本非法")
	end
	for ban_name in pairs(INVALID_NAMES) do
		if string.find(str,ban_name,1,true) then
			return false,language.format("文本包含非法单词")
		end
	end
	return true
end

function cpetdb:bianyi(petid,reason)
	local pet = self:getpet(petid)
	if not pet then
		return
	end
	local bianyidata = data_1700_PetBianyi[pet.type]
	local bianyi_type = choosekey(bianyidata,function(key,data)
		return data.weight
	end)
	logger.log("info","pet",string.format("[bianyi] pid=%d petid=%d type=%d reason=%s",self.pid,petid,bianyi_type,reason))
	pet.bianyi_type = bianyi_type
	self:onupdate(petid,{
		skills = pet:getallskills(),
		bianyi_type = pet.bianyi_type,
	})
end

function cpetdb:getpetsbytype(pettype)
	local pets = {}
	for id,pet in pairs(self.objs) do
		if pet.type == pettype then
			table.insert(pets,pet)
		end
	end
	return pets
end

function cpetdb:expand(addspace,reason)
	logger.log("info","pet",string.format("[expandspace] pid=%d add=%d reason=%s",self.pid,addspace,reason))
	self.expandspace = self.expandspace + addspace
	sendpackage(self.pid,"pet","updatespace",{
		space = self:getspace(),
	})
end

function cpetdb:getnumbytype(pettype)
	local pets = self:getpetsbytype(pettype)
	return #pets
end

function cpetdb:getspace()
	return self.expandspace + self.space
end

function cpetdb:onadd(pet)
	sendpackage(self.pid,"pet","addpet",{
		pet = pet:pack()
	})
end

function cpetdb:ondel(pet)
	sendpackage(self.pid,"pet","delpet",{
		id = pet.id,
	})
end

function cpetdb:onupdate(id,attrs)
	attrs.id = id
	sendpackage(self.pid,"pet","updatepet",{
		pet = attrs,
	})
end

function cpetdb:onfivehourupdate(player)
	for id,pet in pairs(self.objs) do
		local status = randlist(table.keys(data_1700_PetStatus))
		self:change_petstatus(id,status,"onfivehourupdate")
	end
end

function cpetdb:onchangelv(player)
	local oldspace = self:getspace()
	if oldspace >= #data_1700_PetUnlockSpace then
		return
	end
	for num = oldspace + 1,#data_1700_PetUnlockSpace do
		local openlv = data_1700_PetUnlockSpace[num].openlv
		if openlv == -1 or player.lv < openlv then
			break
		end
		self:expand(1,"onchangelv")
	end
end

return cpetdb
